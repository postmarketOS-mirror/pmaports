From 05827d8f77eb023ea2afea0bf688d4c9d0119b49 Mon Sep 17 00:00:00 2001
From: Marius Gripsgard <marius@ubports.com>
Date: Sun, 25 Aug 2019 18:56:17 +0200
Subject: [PATCH 1/2] [spinner] Add support for wayland backend

This adds support for wayland backend to the spinner.

It currently defaults to mir if running on an android device and wayland
device if not.

Backend can be overritten by setting COMPOSITOR_BACKEND.
---
 CMakeLists.txt                 |   1 +
 debian/control                 |   1 +
 spinner/CMakeLists.txt         |  16 +-
 spinner/eglspinner.cpp         |  58 ++++-
 spinner/eglsurface.h           |  28 +++
 spinner/{ => mir}/eglapp.cpp   |   4 +-
 spinner/{ => mir}/eglapp.h     |   4 +-
 spinner/{ => mir}/miregl.cpp   |   0
 spinner/{ => mir}/miregl.h     |   8 +-
 spinner/wayland/eglapp.cpp     |  34 +++
 spinner/wayland/eglapp.h       |  27 ++
 spinner/wayland/waylandegl.cpp | 442 +++++++++++++++++++++++++++++++++
 spinner/wayland/waylandegl.h   |  82 ++++++
 13 files changed, 691 insertions(+), 14 deletions(-)
 create mode 100644 spinner/eglsurface.h
 rename spinner/{ => mir}/eglapp.cpp (98%)
 rename spinner/{ => mir}/eglapp.h (88%)
 rename spinner/{ => mir}/miregl.cpp (100%)
 rename spinner/{ => mir}/miregl.h (89%)
 create mode 100644 spinner/wayland/eglapp.cpp
 create mode 100644 spinner/wayland/eglapp.h
 create mode 100644 spinner/wayland/waylandegl.cpp
 create mode 100644 spinner/wayland/waylandegl.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 484b34c..88ce70f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -42,6 +42,7 @@ pkg_check_modules(GDKPIXBUF REQUIRED gdk-pixbuf-2.0)
 pkg_check_modules(GLIB REQUIRED glib-2.0)
 pkg_check_modules(MIRCLIENT REQUIRED mirclient)
 pkg_check_modules(MIRSERVER REQUIRED mirserver)
+pkg_check_modules(WAYLAND_EGL wayland-egl)
 pkg_check_modules(DBUS REQUIRED dbus-1)
 
 find_package(Boost 1.48.0 COMPONENTS system REQUIRED)
diff --git a/debian/control b/debian/control
index dfb7c03..83438c9 100644
--- a/debian/control
+++ b/debian/control
@@ -20,6 +20,7 @@ Build-Depends: cmake,
                libgtest-dev,
                libmirclient-dev (>= 0.26.0),
                libmirserver-dev (>= 0.26.0),
+               libwayland-dev,
                pkg-config,
                python3,
                python3-pil:native,
diff --git a/spinner/CMakeLists.txt b/spinner/CMakeLists.txt
index 6c22d46..a711f1e 100644
--- a/spinner/CMakeLists.txt
+++ b/spinner/CMakeLists.txt
@@ -56,11 +56,18 @@ endif()
 link_directories(${MIRCLIENT_LIBRARY_DIRS})
 
 add_executable(lomiri-system-compositor-spinner
-  eglapp.cpp
-  eglapp.h
+  mir/eglapp.cpp
+  mir/eglapp.h
+  mir/miregl.h
+  mir/miregl.cpp
+
+  wayland/eglapp.cpp
+  wayland/eglapp.h
+  wayland/waylandegl.h
+  wayland/waylandegl.cpp
+
   eglspinner.cpp
-  miregl.h
-  miregl.cpp
+
   ${CMAKE_CURRENT_BINARY_DIR}/robot.h
   ${CMAKE_CURRENT_BINARY_DIR}/white_dot.h
   ${CMAKE_CURRENT_BINARY_DIR}/orange_dot.h
@@ -73,5 +80,6 @@ target_link_libraries(lomiri-system-compositor-spinner
   ${ANDROIDPROPS_LDFLAGS}
   ${GLESv2_LIBRARIES}
   ${MIRCLIENT_LDFLAGS}
+  ${WAYLAND_EGL_LDFLAGS} ${WAYLAND_EGL_LIBRARIES}
 )
 install(TARGETS lomiri-system-compositor-spinner RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
diff --git a/spinner/eglspinner.cpp b/spinner/eglspinner.cpp
index 246c3c3..43e8e34 100644
--- a/spinner/eglspinner.cpp
+++ b/spinner/eglspinner.cpp
@@ -14,8 +14,9 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "eglapp.h"
-#include "miregl.h"
+#include "eglsurface.h"
+#include "mir/eglapp.h"
+#include "wayland/eglapp.h"
 #include <assert.h>
 #include <gdk-pixbuf/gdk-pixbuf.h>
 #include <glib.h>
@@ -50,6 +51,12 @@ enum TextureIds {
     MAX_TEXTURES
 };
 
+enum Backend {
+    WAYLAND,
+    MIR,
+    UNKOWN = -1
+};
+
 class SessionConfig
 {
 public:
@@ -77,6 +84,17 @@ public:
         return conf_map.find(key) != conf_map.end() ? conf_map[key] : default_value;
     }
 
+    bool is_android() {
+        bool ret = false;
+    #ifdef HAVE_PROPS
+        char const* default_value = "nodevice";
+        char value[PROP_VALUE_MAX];
+        property_get(device_property_key, value, default_value);
+        ret = strcmp(value, default_value) != 0;
+    #endif
+        return ret;
+    }
+
 private:
     void parse_session_conf_file()
     {
@@ -317,7 +335,41 @@ try
     }
     g_clear_error(&error);
 
-    auto const surfaces = mir_eglapp_init(argc, argv);
+    std::vector<std::shared_ptr<EglSurface>> surfaces;
+    char* backendEnv = getenv("COMPOSITOR_BACKEND");
+    Backend backend = UNKOWN;
+
+    if (backendEnv == nullptr) {
+        if (session_config.is_android()) {
+            printf("Running on an Android device, using Mir output.\n");
+            backend = MIR;
+        } else {
+            printf("Not running on an Android device, using Wayland output.\n");
+            backend = WAYLAND;
+        }
+    } else {
+        printf("Using COMPOSITOR_BACKEND varable to set backend\n");
+        if (strcmp(backendEnv, "wayland") == 0) {
+            backend = WAYLAND;
+        }
+        if (strcmp(backendEnv, "mir") == 0) {
+            backend = MIR;
+        }
+    }
+
+    switch(backend) {
+        case MIR:
+            printf("Using mir backend\n");
+            surfaces = mir_eglapp_init(argc, argv);
+            break;
+        case WAYLAND:
+            printf("Using wayland backend\n");
+            surfaces = wayland_eglapp_init(argc, argv);
+            break;
+        default:
+            printf("Uknown backend %s\n", backendEnv);
+            return EXIT_FAILURE;
+    }
 
     if (!surfaces.size())
     {
diff --git a/spinner/eglsurface.h b/spinner/eglsurface.h
new file mode 100644
index 0000000..092fd54
--- /dev/null
+++ b/spinner/eglsurface.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright © 2019 UBports Foundation.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <EGL/egl.h>
+
+#include <memory>
+#include <functional>
+
+class EglSurface
+{
+public:
+    virtual void paint(std::function<void(unsigned int, unsigned int)> const& functor) = 0;
+};
diff --git a/spinner/eglapp.cpp b/spinner/mir/eglapp.cpp
similarity index 98%
rename from spinner/eglapp.cpp
rename to spinner/mir/eglapp.cpp
index 7b7971c..92e2c8d 100644
--- a/spinner/eglapp.cpp
+++ b/spinner/mir/eglapp.cpp
@@ -74,7 +74,7 @@ MirPixelFormat select_pixel_format(MirConnection* connection)
 }
 }
 
-std::vector<std::shared_ptr<MirEglSurface>> mir_eglapp_init(int argc, char *argv[])
+std::vector<std::shared_ptr<EglSurface>> mir_eglapp_init(int argc, char *argv[])
 {
     MirWindowParameters surfaceparm =
         {
@@ -209,7 +209,7 @@ std::vector<std::shared_ptr<MirEglSurface>> mir_eglapp_init(int argc, char *argv
 
     auto const mir_egl_app = make_mir_eglapp(connection, pixel_format);
 
-    std::vector<std::shared_ptr<MirEglSurface>> result;
+    std::vector<std::shared_ptr<EglSurface>> result;
 
     // If a size has been specified just do that
     if (surfaceparm.width && surfaceparm.height)
diff --git a/spinner/eglapp.h b/spinner/mir/eglapp.h
similarity index 88%
rename from spinner/eglapp.h
rename to spinner/mir/eglapp.h
index 9b141e6..cec667a 100644
--- a/spinner/eglapp.h
+++ b/spinner/mir/eglapp.h
@@ -22,10 +22,10 @@
 #include <memory>
 #include <vector>
 
-class MirEglSurface;
+class EglSurface;
 
 extern float mir_eglapp_background_opacity;
 
-std::vector<std::shared_ptr<MirEglSurface>> mir_eglapp_init(int argc, char *argv[]);
+std::vector<std::shared_ptr<EglSurface>> mir_eglapp_init(int argc, char *argv[]);
 
 #endif
diff --git a/spinner/miregl.cpp b/spinner/mir/miregl.cpp
similarity index 100%
rename from spinner/miregl.cpp
rename to spinner/mir/miregl.cpp
diff --git a/spinner/miregl.h b/spinner/mir/miregl.h
similarity index 89%
rename from spinner/miregl.h
rename to spinner/mir/miregl.h
index 1173cc5..d68c50d 100644
--- a/spinner/miregl.h
+++ b/spinner/mir/miregl.h
@@ -17,6 +17,8 @@
 #ifndef LSC_MIREGL_H_
 #define LSC_MIREGL_H_
 
+#include "../eglsurface.h"
+
 #include <mir_toolkit/common.h>
 #include <mir_toolkit/client_types.h>
 #include "mir_toolkit/mir_client_library.h"
@@ -24,6 +26,7 @@
 #include <EGL/egl.h>
 
 #include <memory>
+#include <functional>
 
 class MirEglApp;
 class MirEglSurface;
@@ -32,7 +35,7 @@ std::shared_ptr<MirEglApp> make_mir_eglapp(
     MirConnection* const connection,
     MirPixelFormat const& pixel_format);
 
-class MirEglSurface
+class MirEglSurface : public EglSurface
 {
 public:
     MirEglSurface(
@@ -42,8 +45,7 @@ public:
 
     ~MirEglSurface();
 
-    template<typename Painter>
-    void paint(Painter const& functor)
+    void paint(std::function<void(unsigned int, unsigned int)> const& functor) override
     {
         egl_make_current();
         functor(width(), height());
diff --git a/spinner/wayland/eglapp.cpp b/spinner/wayland/eglapp.cpp
new file mode 100644
index 0000000..804b86e
--- /dev/null
+++ b/spinner/wayland/eglapp.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright © 2013-2018 Canonical Ltd.
+ *             2019 UBports Foundation
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * under the terms of the GNU General Public License version 2 or 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "eglapp.h"
+
+#include "waylandegl.h"
+
+#include <wayland-client.h>
+
+std::vector<std::shared_ptr<EglSurface>> wayland_eglapp_init(int argc, char *argv[])
+{
+    // TODO: add options
+    (void) argc;
+    (void) argv;
+
+    struct wl_display* display = wl_display_connect(NULL);
+    auto const mir_egl_app = make_wayland_eglapp(display);
+
+    return wayland_surface_init(mir_egl_app);
+}
diff --git a/spinner/wayland/eglapp.h b/spinner/wayland/eglapp.h
new file mode 100644
index 0000000..b8a2483
--- /dev/null
+++ b/spinner/wayland/eglapp.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright © 2013 Canonical Ltd.
+ *             2019 UBports Foundation
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * under the terms of the GNU General Public License version 2 or 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Daniel van Vugt <daniel.van.vugt@canonical.com>
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+class EglSurface;
+
+std::vector<std::shared_ptr<EglSurface>> wayland_eglapp_init(int argc, char *argv[]);
diff --git a/spinner/wayland/waylandegl.cpp b/spinner/wayland/waylandegl.cpp
new file mode 100644
index 0000000..2ca2b61
--- /dev/null
+++ b/spinner/wayland/waylandegl.cpp
@@ -0,0 +1,442 @@
+/*
+ * Copyright © 2015-2018 Canonical Ltd.
+ *             2019 UBports Foundation
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * under the terms of the GNU General Public License version 2 or 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "waylandegl.h"
+#include <wayland-client.h>
+
+#include <cstring>
+
+#include <GLES2/gl2.h>
+
+#include <wayland-egl.h>
+
+#include <chrono>
+#include <algorithm>
+
+static void new_global(
+    void* data,
+    struct wl_registry* registry,
+    uint32_t id,
+    char const* interface,
+    uint32_t version);
+
+static void global_remove(
+    void* data,
+    struct wl_registry* registry,
+    uint32_t name)
+{
+    (void)data;
+    (void)registry;
+    (void)name;
+}
+
+static void output_geometry(void */*data*/,
+    struct wl_output */*wl_output*/,
+    int32_t /*x*/,
+    int32_t /*y*/,
+    int32_t /*physical_width*/,
+    int32_t /*physical_height*/,
+    int32_t /*subpixel*/,
+    const char */*make*/,
+    const char */*model*/,
+    int32_t /*transform*/);
+
+static void output_mode(void *data,
+    struct wl_output */*wl_output*/,
+    uint32_t /*flags*/,
+    int32_t width,
+    int32_t height,
+    int32_t /*refresh*/);
+
+static void output_done(void* /*data*/, struct wl_output* /*wl_output*/)
+{
+}
+
+static void output_scale(void* /*data*/, struct wl_output* /*wl_output*/, int32_t /*factor*/)
+{
+}
+
+class WaylandEglApp
+{
+public:
+    WaylandEglApp(struct wl_display* display);
+
+    EGLSurface create_eglsurface(wl_surface* surface, int width, int height);
+
+    void make_current(EGLSurface eglsurface) const;
+
+    void swap_buffers(EGLSurface eglsurface) const;
+
+    void destroy_surface(EGLSurface eglsurface) const;
+
+    void get_surface_size(EGLSurface eglsurface, int* width, int* height) const;
+
+    void set_swap_interval(EGLSurface eglsurface, int interval) const;
+
+    bool supports_surfaceless_context();
+
+    ~WaylandEglApp();
+
+    struct OutputInfo
+    {
+        struct wl_output* wl_output;
+        int32_t x;
+        int32_t y;
+        int32_t width;
+        int32_t height;
+    };
+
+    struct wl_display* const display;
+    struct wl_compositor* compositor;
+    struct wl_shm* shm;
+    struct wl_seat* seat;
+    std::vector<OutputInfo> output_info;
+    struct wl_shell* shell;
+
+private:
+    friend void new_global(
+        void* data,
+        struct wl_registry* registry,
+        uint32_t id,
+        char const* interface,
+        uint32_t version);
+
+    EGLDisplay egldisplay;
+    EGLContext eglctx;
+    EGLConfig eglconfig;
+    EGLint neglconfigs;
+    EGLSurface dummy_surface;
+};
+
+static void output_geometry(void *data,
+    struct wl_output *wl_output,
+    int32_t x,
+    int32_t y,
+    int32_t /*physical_width*/,
+    int32_t /*physical_height*/,
+    int32_t /*subpixel*/,
+    const char */*make*/,
+    const char */*model*/,
+    int32_t /*transform*/)
+{
+    struct WaylandEglApp* app = static_cast<decltype(app)>(data);
+
+    for (auto& oi : app->output_info)
+    {
+        if (wl_output == oi.wl_output)
+        {
+            oi.x = x;
+            oi.y = y;
+            return;
+        }
+    }
+    app->output_info.push_back({wl_output, x, y, 0, 0});
+}
+
+static void output_mode(void *data,
+    struct wl_output *wl_output,
+    uint32_t flags,
+    int32_t width,
+    int32_t height,
+    int32_t /*refresh*/)
+{
+    if (!(WL_OUTPUT_MODE_CURRENT & flags))
+        return;
+
+    struct WaylandEglApp* app = static_cast<decltype(app)>(data);
+
+    for (auto& oi : app->output_info)
+    {
+        if (wl_output == oi.wl_output)
+        {
+            oi.width = width;
+            oi.height = height;
+            return;
+        }
+    }
+    app->output_info.push_back({wl_output, 0, 0, width, height});
+}
+
+static void new_global(
+    void* data,
+    struct wl_registry* registry,
+    uint32_t id,
+    char const* interface,
+    uint32_t version)
+{
+    (void)version;
+    struct WaylandEglApp* app = static_cast<decltype(app)>(data);
+
+    if (strcmp(interface, "wl_compositor") == 0)
+    {
+        app->compositor = static_cast<decltype(app->compositor)>(wl_registry_bind(registry, id, &wl_compositor_interface, 3));
+    }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        app->shm = static_cast<decltype(app->shm)>(wl_registry_bind(registry, id, &wl_shm_interface, 1));
+        // Normally we'd add a listener to pick up the supported formats here
+        // As luck would have it, I know that argb8888 is the only format we support :)
+    }
+    else if (strcmp(interface, "wl_seat") == 0)
+    {
+        app->seat = static_cast<decltype(app->seat)>(wl_registry_bind(registry, id, &wl_seat_interface, 4));
+    }
+    else if (strcmp(interface, "wl_output") == 0)
+    {
+        wl_output* output = static_cast<decltype(output)>(wl_registry_bind(registry, id, &wl_output_interface, 2));
+
+        app->output_info.push_back({output, 0, 0, 0, 0});
+    }
+    else if (strcmp(interface, "wl_shell") == 0)
+    {
+        app->shell = static_cast<decltype(app->shell)>(wl_registry_bind(registry, id, &wl_shell_interface, 1));
+    }
+}
+
+std::shared_ptr<WaylandEglApp> make_wayland_eglapp(struct wl_display* display)
+{
+    return std::make_shared<WaylandEglApp>(display);
+}
+
+std::vector<std::shared_ptr<EglSurface>> wayland_surface_init(std::shared_ptr<WaylandEglApp> const& mir_egl_app)
+{
+    std::vector<std::shared_ptr<EglSurface>> result;
+
+    for (auto const& oi : mir_egl_app->output_info)
+    {
+        result.push_back(std::make_shared<WaylandEglSurface>(mir_egl_app, oi.wl_output, oi.width, oi.height));
+    }
+
+    return result;
+}
+
+WaylandEglSurface::WaylandEglSurface(
+    std::shared_ptr<WaylandEglApp> const& mir_egl_app,
+    struct wl_output* wl_output, int width_, int height_) :
+    mir_egl_app{mir_egl_app},
+    width_{width_},
+    height_{height_}
+{
+    static struct wl_shell_surface_listener const shell_surface_listener = {
+        shell_surface_ping,
+        shell_surface_configure,
+        shell_surface_popup_done
+    };
+
+    display = mir_egl_app->display;
+    surface = wl_compositor_create_surface(mir_egl_app->compositor);
+    window = wl_shell_get_shell_surface(mir_egl_app->shell, surface);
+    wl_shell_surface_add_listener(window, &shell_surface_listener, this);
+    wl_shell_surface_set_fullscreen(window, WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE, 0, wl_output);
+    wl_display_dispatch(display);
+
+    eglsurface = mir_egl_app->create_eglsurface(surface, width(), height());
+
+    mir_egl_app->set_swap_interval(eglsurface, -1);
+}
+
+WaylandEglSurface::~WaylandEglSurface()
+{
+    mir_egl_app->destroy_surface(eglsurface);
+    wl_surface_destroy(surface);
+    wl_shell_surface_destroy(window);
+}
+
+void WaylandEglSurface::egl_make_current()
+{
+    mir_egl_app->get_surface_size(eglsurface, &width_, &height_);
+    mir_egl_app->make_current(eglsurface);
+}
+
+void WaylandEglSurface::swap_buffers()
+{
+    mir_egl_app->swap_buffers(eglsurface);
+}
+
+unsigned int WaylandEglSurface::width() const
+{
+    return width_;
+}
+
+unsigned int WaylandEglSurface::height() const
+{
+    return height_;
+}
+
+void WaylandEglSurface::shell_surface_ping(void */*data*/, struct wl_shell_surface *wl_shell_surface, uint32_t serial)
+{
+    wl_shell_surface_pong(wl_shell_surface, serial);
+}
+
+void WaylandEglSurface::shell_surface_configure(void *data,
+    struct wl_shell_surface */*wl_shell_surface*/,
+    uint32_t /*edges*/,
+    int32_t width,
+    int32_t height)
+{
+    auto self = static_cast<WaylandEglSurface*>(data);
+    if (width) self->width_ = width;
+    if (height) self->height_ = height;
+}
+
+void WaylandEglSurface::shell_surface_popup_done(void */*data*/, struct wl_shell_surface */*wl_shell_surface*/)
+{
+}
+
+WaylandEglApp::WaylandEglApp(struct wl_display* display) :
+    display{display},
+    dummy_surface{EGL_NO_SURFACE}
+{
+    static struct wl_registry_listener const registry_listener = {
+        new_global,
+        global_remove
+    };
+
+    wl_registry_add_listener(wl_display_get_registry(display), &registry_listener, this);
+    wl_display_roundtrip(display);
+
+    static struct wl_output_listener const output_listener = {
+        &output_geometry,
+        &output_mode,
+        &output_done,
+        &output_scale,
+    };
+
+    for (auto const oi : output_info)
+        wl_output_add_listener(oi.wl_output, &output_listener, this);
+
+    wl_display_roundtrip(display);
+
+    unsigned int bpp = 32; //8*MIR_BYTES_PER_PIXEL(pixel_format);
+
+    EGLint attribs[] =
+        {
+            EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
+            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+            EGL_COLOR_BUFFER_TYPE, EGL_RGB_BUFFER,
+            EGL_BUFFER_SIZE, (EGLint) bpp,
+            EGL_NONE
+        };
+
+    egldisplay = eglGetDisplay((EGLNativeDisplayType)(display));
+    if (egldisplay == EGL_NO_DISPLAY)
+        throw std::runtime_error("Can't eglGetDisplay");
+
+    EGLint major;
+    EGLint minor;
+    if (!eglInitialize(egldisplay, &major, &minor))
+        throw std::runtime_error("Can't eglInitialize");
+
+    if (major != 1 || minor < 4)
+        throw std::runtime_error("EGL version is not at least 1.4");
+
+    if (!eglChooseConfig(egldisplay, attribs, &eglconfig, 1, &neglconfigs))
+        throw std::runtime_error("Could not eglChooseConfig");
+
+    if (neglconfigs == 0)
+        throw std::runtime_error("No EGL config available");
+
+    EGLint ctxattribs[] =
+        {
+            EGL_CONTEXT_CLIENT_VERSION, 2,
+            EGL_NONE
+        };
+
+    eglctx = eglCreateContext(egldisplay, eglconfig, EGL_NO_CONTEXT, ctxattribs);
+    if (eglctx == EGL_NO_CONTEXT)
+        throw std::runtime_error("eglCreateContext failed");
+
+    if (!supports_surfaceless_context())
+    {
+        static EGLint const dummy_pbuffer_attribs[] =
+        {
+             EGL_WIDTH, 1,
+             EGL_HEIGHT, 1,
+             EGL_NONE
+        };
+
+        dummy_surface = eglCreatePbufferSurface(egldisplay, eglconfig, dummy_pbuffer_attribs);
+        if (dummy_surface == EGL_NO_SURFACE)
+            throw std::runtime_error("eglCreatePbufferSurface failed");
+    }
+
+    make_current(dummy_surface);
+}
+
+EGLSurface WaylandEglApp::create_eglsurface(wl_surface* surface, int width, int height)
+{
+
+    auto const eglsurface = eglCreateWindowSurface(
+        egldisplay,
+        eglconfig,
+        (EGLNativeWindowType)wl_egl_window_create(surface, width, height), NULL);
+
+    if (eglsurface == EGL_NO_SURFACE)
+        throw std::runtime_error("eglCreateWindowSurface failed");
+
+    return eglsurface;
+}
+
+void WaylandEglApp::make_current(EGLSurface eglsurface) const
+{
+    if (!eglMakeCurrent(egldisplay, eglsurface, eglsurface, eglctx))
+        throw std::runtime_error("Can't eglMakeCurrent");
+}
+
+void WaylandEglApp::swap_buffers(EGLSurface eglsurface) const
+{
+    eglSwapBuffers(egldisplay, eglsurface);
+}
+
+void WaylandEglApp::destroy_surface(EGLSurface eglsurface) const
+{
+    eglDestroySurface(egldisplay, eglsurface);
+}
+
+void WaylandEglApp::get_surface_size(EGLSurface eglsurface, int* width, int* height) const
+{
+    eglQuerySurface(egldisplay, eglsurface, EGL_WIDTH, width);
+    eglQuerySurface(egldisplay, eglsurface, EGL_HEIGHT, height);
+}
+
+void WaylandEglApp::set_swap_interval(EGLSurface eglsurface, int interval) const
+{
+    auto const previous_surface = eglGetCurrentSurface(EGL_DRAW);
+
+    make_current(eglsurface);
+    eglSwapInterval(egldisplay, interval);
+
+    if (previous_surface != EGL_NO_SURFACE)
+        make_current(previous_surface);
+}
+
+bool WaylandEglApp::supports_surfaceless_context()
+{
+    auto const extensions = eglQueryString(egldisplay, EGL_EXTENSIONS);
+    if (!extensions)
+        return false;
+    return std::strstr(extensions, "EGL_KHR_surfaceless_context") != nullptr;
+}
+
+WaylandEglApp::~WaylandEglApp()
+{
+    eglMakeCurrent(egldisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+    if (dummy_surface != EGL_NO_SURFACE)
+        destroy_surface(dummy_surface);
+    eglDestroyContext(egldisplay, eglctx);
+    eglTerminate(egldisplay);
+}
diff --git a/spinner/wayland/waylandegl.h b/spinner/wayland/waylandegl.h
new file mode 100644
index 0000000..e5c99e7
--- /dev/null
+++ b/spinner/wayland/waylandegl.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright © 2015-2018 Canonical Ltd.
+ *             2019 UBports Foundation
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * under the terms of the GNU General Public License version 2 or 3 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include "../eglsurface.h"
+
+#include <EGL/egl.h>
+
+#include <memory>
+#include <vector>
+#include <functional>
+
+class WaylandEglApp;
+class EglSurface;
+
+std::shared_ptr<WaylandEglApp> make_wayland_eglapp(struct wl_display* display);
+std::vector<std::shared_ptr<EglSurface>> wayland_surface_init(std::shared_ptr<WaylandEglApp> const& app);
+
+class WaylandEglSurface : public EglSurface
+{
+public:
+    WaylandEglSurface(std::shared_ptr<WaylandEglApp> const& mir_egl_app, struct wl_output* wl_output, int width, int height);
+
+    ~WaylandEglSurface();
+
+    void paint(std::function<void(unsigned int, unsigned int)> const& functor) override
+    {
+        egl_make_current();
+        functor(width(), height());
+        swap_buffers();
+    }
+
+private:
+    void egl_make_current();
+
+    void swap_buffers();
+    unsigned int width() const;
+    unsigned int height() const;
+
+    std::shared_ptr<WaylandEglApp> const mir_egl_app;
+
+    void* content_area = nullptr;
+    struct wl_display* display = nullptr;
+    struct wl_surface* surface = nullptr;
+    struct wl_callback* new_frame_signal = nullptr;
+    struct wl_shell_surface* window = nullptr;
+    struct Buffers
+    {
+        struct wl_buffer* buffer;
+        bool available;
+    } buffers[4];
+    bool waiting_for_buffer = true;
+
+    EGLSurface eglsurface;
+    int width_;
+    int height_;
+
+    static void shell_surface_ping(void *data, struct wl_shell_surface *wl_shell_surface, uint32_t serial);
+
+    static void shell_surface_configure(void *data,
+        struct wl_shell_surface *wl_shell_surface,
+        uint32_t edges,
+        int32_t width,
+        int32_t height);
+    static void shell_surface_popup_done(void *data, struct wl_shell_surface *wl_shell_surface);
+
+};
-- 
2.31.1

